// основная библиотека SGDK
#include "genesis.h"
// подключаем библиотеку сгенерированную SGDK из resources.res
#include "resouces.h"

// точка входа в программу (игру)
int main(bool hardReset) {

    // выводим на экран "BlodTor"
    // 1 параметр - строка которую хотим вывести на экран
    // 2 и 3 параметр - x и y на тайловой сетке, где выводить текст
	VDP_drawText("Hello BlodTor!!!", 13, 18);

	// индекс последнего тайла в VRAM с которого можно добавить новые пользовательнские тайлы
	u16 ind = TILE_USER_INDEX;

    // устанавливаем первой палитре цвета из палитры у файла
    // 1 параметр - номер палитры (PAL0, PAL1, PAL2, PAL3)
    // 2 параметр - палитра из объекта изображения, имя которого мы указали в resources.res
    // 3 параметр - способ передачи (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
	PAL_setPalette(PAL1, bg_B.palette->data, DMA);

	// рисуем на заднем фоне картинку с заднем фоном из соника файл
	// 1 параметр - слой, на котором будет отресовано изображение (BG_A, BG_B, WINDOW)
	// 2 параметр - объект изображения, имя которого мы указали в resources.res
	// 3 параметр - атрибуты тайлов для tilemap (через макрос TILE_ATTR_FULL)
	//								1 параметр - палитра (PAL0, PAL1, PAL2, PAL3)
	//                              2 параметр - включить приоритеты тайлов
	//                              3 параметр - отоброзить тайлы по вертикали
	//                              4 параметр - отоброзить тайлы по горизонтали
	// 								5 параметр - индекс тайла в VRAM с которого будут наши тайлы
	// 4 и 5 параметр - координаты на тайловой сетке x, y
	// 6 параметр - загружать ли из переданного рессурса в палитру цвета
	// 7 параметр - способ передачи данных TRUE - DMA, FALSE - CPU
	VDP_drawImageEx(BG_B, &bg_B, TILE_ATTR_FULL(PAL1, FALSE, FALSE, FALSE, ind), 0, 0, FALSE, TRUE);
	ind += bg_B.tileset->numTile;

    // устанавливаем цвет текста белым
    // в нулевой палитре 15 цвет будет белого цета
	PAL_setColor(15, RGB24_TO_VDPCOLOR(0xff0000));

    // устанавливаем режим прокрутки, горизонтальная прокрутка: скролл тайлов, вертикальная: скролл слоя
    // 1 параметр - горизонтальная прокрутка
    // HSCROLL_PLANE - скролл слоя, HSCROLL_TILE - скролл тайлов, HSCROLL_LINE — скролл линий.
    // 2 параметр - вертикальная прокрутка
    // VSCROLL_PLANE - скролл слоя, VSCROLL_COLUMN - скролл мета-тайла (1 метатайла = 4 тайла = 16×16 px)
	VDP_setScrollingMode(HSCROLL_TILE, VSCROLL_PLANE);


    // указываем размер слоя в тайлах
    // доступны значения 32*32, 32*64, 32*128, 64*32, 64*64, 128*32
    // 1 параметр - задает ширину слоя в тайлах
    // 2 параметр - задает высоту слоя в тайлах
    // 3 параметр - если TRUE, то тайловые карты, будут автоматически распределятся по VRAM в зависимости от размера слоя
    // лучше ставить TRUE, чтобы случайно не получить мусорные тайлы на слое
	VDP_setPlaneSize(64, 32, TRUE);

    // массив хранящий скорость скролла мета-тайлов.
	s16 offset_mask[29];

    //все данные массива сбрасываю в 0
    // 1 параметр - массив
    // 2 параметр - значение которое хотим выставить
    // 3 параметр - рпзмер в байтах (т.к. тип s16 = 2 байта, то размер массива 29 умножаем на 2)
	memset(offset_mask, 0, 29*2);

    // загружаем палитру в CRAM из палитры определенной в resources.res из файла S1_GHZ1_FG.png
    // 1 параметр - индекс цвета с которого меняем палитру
    // 2 параметр - объект палитры определенный в resources.res
    // 3 параметр - индекс цвета до которого меняем палитру (значение не больше 64, т.к. 4 палитры по 16 цетов)
    // 4 параметр - способ передачи данных (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
	PAL_setColors(0, palette_fg.data, 64, DMA);

	// загружаем тайлы (tileset) в VRAM из тайлсета определенного в resources.res
	// 1 параметр - объект tileset, уникальные тайлы, определенные в resources.res
	// 2 параметр - индекс тайла в VRAM с которого будут загружены тайлы из tileset
	// 3 параметр - способ передачи данных (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
	VDP_loadTileSet(&tileset_fg, ind, DMA);

    // создаем карту уровня на слое BG_A из карты тайлов определенный в resources.res (map_fg), используя макрос TILE_ATTR_FULL
    // 1 параметр - tilemap - карта индексов тайлов из тайлсета что рание грузили
    // 2 параметр - слой (BG_A или BG_B)
    // 3 параметр - атрибуты тайлов для tilemap (через макрос TILE_ATTR_FULL)
	//								1 параметр - палитра (PAL0, PAL1, PAL2, PAL3)
	//                              2 параметр - включить приоритеты тайлов
	//                              3 параметр - отоброзить тайлы по вертикали
	//                              4 параметр - отоброзить тайлы по горизонтали
	// 								5 параметр - индекс тайла в VRAM с которого будут наши тайлы
	Map* fgMap = MAP_create(&map_fg, BG_A, TILE_ATTR_FULL(PAL0, FALSE, FALSE, FALSE, ind));

    // Устанавливаем позицию на карте уровне игры в пикселах, какую часть уровня отображаем
    // 1 параметр - карта уровеня игры
    // 2 и 3 параметр - координаты x и y в пикселах на карте уровня
	MAP_scrollTo(fgMap, 0, 768);

	// смещение по x на карте уровня игры
	s16 scroll_bga_x = 0;

	// бесконечный цикл
    while(TRUE) {

    	// вертикальный скролл тайлов каждой строки с своей скоростью заданной в массиве смещений offset_mask
    	// 1 параметр - слой строки тайлов которого будем смещать с разной скоростью (может быть BG_A, BG_B)
    	// 2 параметр - номер первой строки тайлов которую будем смещать
    	// 3 параметр - массив хранящий значение смещения каждой строки тайлов
    	// 4 параметр - номер последней строки тайлов которую будем смещать
    	// 5 параметр - способ передачи данных (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
    	VDP_setHorizontalScrollTile(BG_B, 0, offset_mask, 28, CPU);

    	// меняем смещения в массиве для каждой строки тайлов
    	// движение неба на заднем фоне
    	offset_mask[0] += 1;
    	offset_mask[1] += 1;
    	offset_mask[2] += 2;
    	offset_mask[3] += 3;
    	offset_mask[4] += 3;
    	offset_mask[5] += 4;

    	// движение гор и остравов на заднем фоне
    	for (int i = 7; i < 18; i++) {
    		offset_mask[i] -= 1;
    	}

    	// движение воды
    	for (int j = 18; j < 28; j++) {
    		offset_mask[j] -= (j - 15);
    	}

    	// Устанавливаем позицию на карте уровне игры в пикселах, какую часть уровня отображаем
    	MAP_scrollTo(fgMap, scroll_bga_x, 768);

    	// изменяем смещение по x на 2 для карты уровня иры
    	scroll_bga_x += 2;

    	// ждем отрисовки кадра
    	SYS_doVBlankProcess();
    }

    return 0;
}
