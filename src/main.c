// основная библиотека SGDK
#include "genesis.h"
// подключаем библиотеку сгенерированную SGDK из resources.res
#include "resources.h"

// точка входа в программу (игру)
int main(bool hardReset) {
    // инициализируем спрайтовый движок (выделяем место в VRAM под спрайты)
    SPR_init();

	// устанавливаем первой палитре цвета из палитры в файле rapuncel.png
	// 1 параметр - номер палитры (PAL0, PAL1, PAL2, PAL3)
	// 2 параметр - палитра из объекта изображения, имя которого мы указали в resources.res
	// 3 параметр - способ передачи (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
	PAL_setPalette(PAL1, rapuncel.palette->data, DMA);

    // добавляем спрайт Рапунцель на экран
	// 1 параметр ссылка на ресурс из resources.res
	// 2 параметр координата x
	// 3 параметр координата y
	// 4 параметр атрибуты (TILE_ATTR)
	// возвращает указатель на struct Sprite который используем далее в коде
    Sprite*  rapuncelSprite = SPR_addSprite(&rapuncel, 80, 80,
                                    TILE_ATTR(PAL1       // палитра
                                                , 0      // приоритет спрайта (спрайт с меньшим числом, будет перекрывать спрайт с большим)
                                                , FALSE  // перевернуть по вертикали
                                                , FALSE  // перевернуть по горизонтали
                                              )
                                );

	// выводим на экран "Hello BlodTor!!!"
	// 1 параметр - строка которую хотим вывести на экран
	// 2 и 3 параметр - x и y на тайловой сетке, где выводить текст
	VDP_drawText("Hello BlodTor!!!", 13, 18);

	// рисуем на заднем фоне картинку с надписью SEGA из файла sega.png
	// 1 параметр - слой, на котором установлено изображение (BG_A, BG_B, WINDOW)
	// 2 параметр - объект изображения, имя которого мы указали в resources.res
	// 3 и 4 - координаты на тайловой сетке x, y в тайлах
	VDP_drawImage(BG_B, &bg_sega, 0, 0);

	// куда смотрит Рапунцель. FALSE - вправо, TRUE - влево
	u8 hFlipRapuncel = FALSE;

	// что нажато на первом контроллере
	u16 joy1 = 0;

	// координата X спрайта Рапунцель
	s16 xRapuncel = 80;

	// количество циклов которое не нажимали на кнопки контроллера
	// на самом деле только 'влево' и 'вправо', нажатие остальных кнопок ни на что не влияет
	// когда достигнет 128 рапунцель начнет чисать волосы
	u8 time = 0;

	do {
		// запоминаем в joy1 состояние кнопок первого контроллера (что нажато что нет)
		joy1 = JOY_readJoypad(JOY_1);

		// спрайт Рапунцель нарисавать как есть если hFlipRapuncel == FALSE (будет смотреть вправо)
		// если hFlipRapuncel == TRUE отобразить спрайт Рапунцель по горизониали (будет смотреть влево)
		SPR_setHFlip(rapuncelSprite, hFlipRapuncel);

		// меняем позицию спрайта Рапунцель X = xRapuncel, Y = 20
		SPR_setPosition(rapuncelSprite, xRapuncel, 20);

		if (joy1 & BUTTON_RIGHT) {
			// нажата кнопка 'вправо'
			// сбрасываем количество циклов которое не нажимали кнопки в 0
			time = 0;
			// чтоб Рапунцель смотрела вправо
			hFlipRapuncel = FALSE;
			// меняем позицию Рапунцель вправо на 1 (ходьба)
			xRapuncel += 1;

			if (joy1 & BUTTON_B) {
				// нажата кнопка 'B' (и кнопка 'вправо')
				// меняем позицию Рапунцель вправо  еще на 2 (бег)
				xRapuncel += 2;
				// меняем анимацию спрайта Рапунцель на бег
				SPR_setAnim(rapuncelSprite, 3);
			} else {
				// кнопка 'B' НЕ нажата (только 'вправо' нажата)
				// меняем анимацию спрайта Рапунцель на ходьбу
				SPR_setAnim(rapuncelSprite, 2);
			}
		} else if (joy1 & BUTTON_LEFT) {
			// нажата кнопка 'влево'
			// сбрасываем количество циклов которое не нажимали кнопки в 0
			time = 0;
			// чтоб Рапунцель смотрела влево
			hFlipRapuncel = TRUE;
			// меняем позицию Рапунцель влево на 1 (ходьба)
			xRapuncel -= 1;

			if (joy1 & BUTTON_B) {
				// нажата кнопка 'B' (и кнопка 'влево')
				// меняем позицию Рапунцель влево еще на 2 (бег)
				xRapuncel -= 2;
				// меняем анимацию спрайта Рапунцель на бег
				SPR_setAnim(rapuncelSprite, 3);
			} else {
				// кнопка 'B' НЕ нажата (только 'влево' нажата)
				// меняем анимацию спрайта Рапунцель на ходьбу
				SPR_setAnim(rapuncelSprite, 2);
			}
		} else {
			// кнопки 'влево' и 'вправо' не нажаты
			// количество циклов которое не нажимали кнопки увиличиваем на еденицу
			time++;

			if (time < 128) {
				// устанавливаем анимацию когда Рапунцель просто стоит с вытянутой сковородой
				SPR_setAnim(rapuncelSprite, 0);
			} else {
				// time стало 128 или больше 128
				// устанавливаем спрайту Рапунцель анимацию при которой она чешет волосы
				SPR_setAnim(rapuncelSprite, 1);
			}
		}

        // Обновляет и отображает спрайты на экране
        SPR_update();

		// ждем отрисовки кадра
		SYS_doVBlankProcess();

		// цикл продолжается пока не нажмем кнопку А (BUTTON_A) на первом контролере (JOY_1)
	} while (!(joy1 & BUTTON_A));

	// ******************************* 1 **************************************************************

	// устанавливаем цвет текста красным
	// в нулевой палитре 15 цвет будет красного цета
	PAL_setColor(15, RGB24_TO_VDPCOLOR(0xff0000));

	// устанавливаем первой палитре цвета из палитры в файле sega.png
	// 1 параметр - номер палитры (PAL0, PAL1, PAL2, PAL3)
	// 2 параметр - палитра из объекта изображения, имя которого мы указали в resources.res
	// 3 параметр - способ передачи (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
	PAL_setPalette(PAL1, bg_sega.palette->data, DMA);

	// индекс последнего тайла в VRAM с которого можно добавить новые пользовательнские тайлы
	u16 ind = TILE_USER_INDEX;

	// рисуем на заднем фоне картинку с заднем фоном SEGA из файла sega.png
	// 1 параметр - слой, на котором будет отресовано изображение (BG_A, BG_B, WINDOW)
	// 2 параметр - объект изображения, имя которого мы указали в resources.res
	// 3 параметр - атрибуты тайлов для tilemap (через макрос TILE_ATTR_FULL)
	//								1 параметр - палитра (PAL0, PAL1, PAL2, PAL3)
	//                              2 параметр - включить приоритеты тайлов
	//                              3 параметр - отоброзить тайлы по вертикали
	//                              4 параметр - отоброзить тайлы по горизонтали
	// 								5 параметр - индекс тайла в VRAM с которого будут наши тайлы
	// 4 и 5 параметр - координаты на тайловой сетке x, y
	// 6 параметр - загружать ли из переданного рессурса в палитру цвета
	// 7 параметр - способ передачи данных TRUE - DMA, FALSE - CPU
	VDP_drawImageEx(BG_B, &bg_sega,
			TILE_ATTR_FULL(PAL1, FALSE, FALSE, FALSE, ind), 0, 0, FALSE, TRUE);

	do {
		// ждем отрисовки кадра
		SYS_doVBlankProcess();

		// цикл продолжается пока не нажмем кнопку B (BUTTON_B) на первом контролере (JOY_1)
	} while (!(JOY_readJoypad(JOY_1) & BUTTON_B));

	// ******************************* 2 **************************************************************

	// устанавливаем первой палитре цвета из палитры в файле bgb.png
	// 1 параметр - номер палитры (PAL0, PAL1, PAL2, PAL3)
	// 2 параметр - палитра из объекта изображения, имя которого мы указали в resources.res
	// 3 параметр - способ передачи (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
	PAL_setPalette(PAL1, bg_B.palette->data, DMA);

	// рисуем на заднем фоне картинку с заднем фоном из соника файл bgb.png
	// 1 параметр - слой, на котором будет отресовано изображение (BG_A, BG_B, WINDOW)
	// 2 параметр - объект изображения, имя которого мы указали в resources.res
	// 3 параметр - атрибуты тайлов для tilemap (через макрос TILE_ATTR_FULL)
	//								1 параметр - палитра (PAL0, PAL1, PAL2, PAL3)
	//                              2 параметр - включить приоритеты тайлов
	//                              3 параметр - отоброзить тайлы по вертикали
	//                              4 параметр - отоброзить тайлы по горизонтали
	// 								5 параметр - индекс тайла в VRAM с которого будут наши тайлы
	// 4 и 5 параметр - координаты на тайловой сетке x, y
	// 6 параметр - загружать ли из переданного рессурса в палитру цвета
	// 7 параметр - способ передачи данных TRUE - DMA, FALSE - CPU
	VDP_drawImageEx(BG_B, &bg_B, TILE_ATTR_FULL(PAL1, FALSE, FALSE, FALSE, ind),
			0, 0, FALSE, TRUE);

	// устанавливаем новый индекс последнего тайла в VRAM с которого можно добавить новые пользовательнские тайлы
	ind += bg_B.tileset->numTile;

	// устанавливаем режим прокрутки, горизонтальная прокрутка: скролл тайлов, вертикальная: скролл слоя
	// 1 параметр - горизонтальная прокрутка
	// HSCROLL_PLANE - скролл слоя, HSCROLL_TILE - скролл тайлов, HSCROLL_LINE — скролл линий.
	// 2 параметр - вертикальная прокрутка
	// VSCROLL_PLANE - скролл слоя, VSCROLL_COLUMN - скролл мета-тайла (1 метатайла = 4 тайла = 16×16 px)
	VDP_setScrollingMode(HSCROLL_TILE, VSCROLL_PLANE);

	// указываем размер слоя в тайлах
	// доступны значения 32*32, 32*64, 32*128, 64*32, 64*64, 128*32
	// 1 параметр - задает ширину слоя в тайлах
	// 2 параметр - задает высоту слоя в тайлах
	// 3 параметр - если TRUE, то тайловые карты, будут автоматически распределятся по VRAM в зависимости от размера слоя
	// лучше ставить TRUE, чтобы случайно не получить мусорные тайлы на слое
	VDP_setPlaneSize(64, 32, TRUE);

	// массив хранящий скорость скролла строк тайлов
	s16 offset_mask[29];

	//все данные массива сбрасываю в 0
	// 1 параметр - массив
	// 2 параметр - значение которое хотим выставить
	// 3 параметр - рпзмер в байтах (т.к. тип s16 = 2 байта, то размер массива 29 умножаем на 2)
	memset(offset_mask, 0, 29 * 2);

	do {

		// вертикальный скролл тайлов каждой строки с своей скоростью заданной в массиве смещений offset_mask
		// 1 параметр - слой строки тайлов которого будем смещать с разной скоростью (может быть BG_A, BG_B)
		// 2 параметр - номер первой строки тайлов которую будем смещать
		// 3 параметр - массив хранящий значение смещения каждой строки тайлов
		// 4 параметр - номер последней строки тайлов которую будем смещать
		// 5 параметр - способ передачи данных (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
		VDP_setHorizontalScrollTile(BG_B, 0, offset_mask, 28, CPU);

		// меняем смещения в массиве для каждой строки тайлов
		// движение неба на заднем фоне
		offset_mask[0] += 1;
		offset_mask[1] += 1;
		offset_mask[2] += 2;
		offset_mask[3] += 3;
		offset_mask[4] += 3;
		offset_mask[5] += 4;

		// движение гор и остравов на заднем фоне
		for (int i = 7; i < 18; i++) {
			offset_mask[i] -= 1;
		}

		// движение воды
		for (int j = 18; j < 28; j++) {
			offset_mask[j] -= (j - 15);
		}

		// ждем отрисовки кадра
		SYS_doVBlankProcess();

		// цикл продолжается пока не нажмем кнопку C (BUTTON_C) на первом контролере (JOY_1)
	} while (!(JOY_readJoypad(JOY_1) & BUTTON_C));

	// ******************************* 3 **************************************************************

	// загружаем палитру в CRAM из палитры определенной в resources.res из файла S1_GHZ1_FG.png
	// 1 параметр - индекс цвета с которого меняем палитру
	// 2 параметр - объект палитры определенный в resources.res
	// 3 параметр - индекс цвета до которого меняем палитру (значение не больше 64, т.к. 4 палитры по 16 цетов)
	// 4 параметр - способ передачи данных (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
	PAL_setColors(0, palette_fg.data, 64, DMA);

	// загружаем тайлы (tileset) в VRAM из тайлсета определенного в resources.res файла S1_GHZ1_FG.png
	// 1 параметр - объект tileset, уникальные тайлы, определенные в resources.res
	// 2 параметр - индекс тайла в VRAM с которого будут загружены тайлы из tileset
	// 3 параметр - способ передачи данных (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
	VDP_loadTileSet(&tileset_fg, ind, DMA);

	// создаем карту уровня на слое BG_A из карты тайлов определенный в resources.res (map_fg), используя макрос TILE_ATTR_FULL файла S1_GHZ1_FG.png
	// 1 параметр - tilemap - карта индексов тайлов из тайлсета что рание грузили
	// 2 параметр - слой (BG_A или BG_B)
	// 3 параметр - атрибуты тайлов для tilemap (через макрос TILE_ATTR_FULL)
	//								1 параметр - палитра (PAL0, PAL1, PAL2, PAL3)
	//                              2 параметр - включить приоритеты тайлов
	//                              3 параметр - отоброзить тайлы по вертикали
	//                              4 параметр - отоброзить тайлы по горизонтали
	// 								5 параметр - индекс тайла в VRAM с которого будут наши тайлы
	Map *fgMap = MAP_create(&map_fg, BG_A,
			TILE_ATTR_FULL(PAL0, FALSE, FALSE, FALSE, ind));

	// устанавливаем новый индекс последнего тайла в VRAM с которого можно добавить новые пользовательнские тайлы
	ind += tileset_fg.numTile;

	// Устанавливаем позицию на карте уровне игры в пикселах, какую часть уровня отображаем
	// 1 параметр - карта уровеня игры
	// 2 и 3 параметр - координаты x и y в пикселах на карте уровня
	MAP_scrollTo(fgMap, 0, 768);

	// смещение по x на карте уровня игры
	s16 scroll_bga_x = 0;

	do {

		// вертикальный скролл тайлов каждой строки с своей скоростью заданной в массиве смещений offset_mask
		// 1 параметр - слой строки тайлов которого будем смещать с разной скоростью (может быть BG_A, BG_B)
		// 2 параметр - номер первой строки тайлов которую будем смещать
		// 3 параметр - массив хранящий значение смещения каждой строки тайлов
		// 4 параметр - номер последней строки тайлов которую будем смещать
		// 5 параметр - способ передачи данных (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
		VDP_setHorizontalScrollTile(BG_B, 0, offset_mask, 28, CPU);

		// меняем смещения в массиве для каждой строки тайлов
		// движение неба на заднем фоне
		offset_mask[0] += 1;
		offset_mask[1] += 1;
		offset_mask[2] += 2;
		offset_mask[3] += 3;
		offset_mask[4] += 3;
		offset_mask[5] += 4;

		// движение гор и остравов на заднем фоне
		for (int i = 7; i < 18; i++) {
			offset_mask[i] -= 1;
		}

		// движение воды
		for (int j = 18; j < 28; j++) {
			offset_mask[j] -= (j - 15);
		}

		// Устанавливаем позицию на карте уровне игры в пикселах, какую часть уровня отображаем
		MAP_scrollTo(fgMap, scroll_bga_x, 768);

		// изменяем смещение по x на 2 для карты уровня иры
		scroll_bga_x += 2;

		// ждем отрисовки кадра
		SYS_doVBlankProcess();

		// цикл продолжается пока не нажмем кнопку start (BUTTON_START) на первом контролере (JOY_1)
	} while (!(JOY_readJoypad(JOY_1) & BUTTON_START));

	// ******************************* 4 **************************************************************

	// рисуем на WINDOW картинку из файла bgw.png
	// 1 параметр - слой, на котором будет отресовано изображение (BG_A, BG_B, WINDOW)
	// 2 параметр - объект изображения, имя которого мы указали в resources.res
	// 3 параметр - атрибуты тайлов для tilemap (через макрос TILE_ATTR_FULL)
	//								1 параметр - палитра (PAL0, PAL1, PAL2, PAL3)
	//                              2 параметр - включить приоритеты тайлов
	//                              3 параметр - отоброзить тайлы по вертикали
	//                              4 параметр - отоброзить тайлы по горизонтали
	// 								5 параметр - индекс тайла в VRAM с которого будут наши тайлы
	// 4 и 5 параметр - координаты на тайловой сетке x, y
	// 6 параметр - загружать ли из переданного рессурса в палитру цвета
	// 7 параметр - способ передачи данных TRUE - DMA, FALSE - CPU
	VDP_drawImageEx(WINDOW, &bg_W,
			TILE_ATTR_FULL(PAL0, FALSE, FALSE, FALSE, ind), 0, 0, FALSE, TRUE);

	// Отображает Окно (слой WINDOW на слое BG_A) с верхнего края до базовой точки pos Окна.
	// 1 параметр - если true, Отображает Окна с базовой точки pos Окна до нижнего края.
	//              если false, Отображает Окно с верхнего края до базовой точки pos Окна.
	// 				шаг по 2 тайла в отличае от VDP_setWindowVPos где шаг 1 тайл
	// 2 параметр - pos, координата y (строка в тайлах) - базовая точка для первого параметра
	VDP_setWindowVPos(FALSE, 4);

	// Отображает Окно (слой WINDOW на слое BG_A) с левого края до базовой точки pos Окна.
	// 1 параметр - если true, Отображает Окно с базовой точки pos Окна до правого края.
	//              если false, Отображает Окно с левого края до базовой точки pos Окна.
	// 				шаг по 2 тайла в отличае от VDP_setWindowVPos где шаг 1 тайл
	// 2 параметр - pos, координата x (столбец * 2 в тайлах) - базовая точка для первого параметра
	VDP_setWindowHPos(FALSE, 2);

	// бесконечный цикл
	while (TRUE) {

		// вертикальный скролл тайлов каждой строки с своей скоростью заданной в массиве смещений offset_mask
		// 1 параметр - слой строки тайлов которого будем смещать с разной скоростью (может быть BG_A, BG_B)
		// 2 параметр - номер первой строки тайлов которую будем смещать
		// 3 параметр - массив хранящий значение смещения каждой строки тайлов
		// 4 параметр - номер последней строки тайлов которую будем смещать
		// 5 параметр - способ передачи данных (CPU, DMA, DMA_QUEUE, DMA_QUEUE_COPY)
		VDP_setHorizontalScrollTile(BG_B, 0, offset_mask, 28, CPU);

		// меняем смещения в массиве для каждой строки тайлов
		// движение неба на заднем фоне
		offset_mask[0] += 1;
		offset_mask[1] += 1;
		offset_mask[2] += 2;
		offset_mask[3] += 3;
		offset_mask[4] += 3;
		offset_mask[5] += 4;

		// движение гор и остравов на заднем фоне
		for (int i = 7; i < 18; i++) {
			offset_mask[i] -= 1;
		}

		// движение воды
		for (int j = 18; j < 28; j++) {
			offset_mask[j] -= (j - 15);
		}

		// Устанавливаем позицию на карте уровне игры в пикселах, какую часть уровня отображаем
		MAP_scrollTo(fgMap, scroll_bga_x, 768);

		// изменяем смещение по x на 2 для карты уровня иры
		scroll_bga_x += 2;

		// ждем отрисовки кадра
		SYS_doVBlankProcess();
	}

	// ******************************* 5 **************************************************************

	return 0;
}
